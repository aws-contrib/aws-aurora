// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/aws-contrib/aws-aurora/internal/database/ent"
)

type FakeGateway struct {
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreateSchemaSysStub        func(context.Context) error
	createSchemaSysMutex       sync.RWMutex
	createSchemaSysArgsForCall []struct {
		arg1 context.Context
	}
	createSchemaSysReturns struct {
		result1 error
	}
	createSchemaSysReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTableJobsStub        func(context.Context) error
	createTableJobsMutex       sync.RWMutex
	createTableJobsArgsForCall []struct {
		arg1 context.Context
	}
	createTableJobsReturns struct {
		result1 error
	}
	createTableJobsReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTableLocksStub        func(context.Context) error
	createTableLocksMutex       sync.RWMutex
	createTableLocksArgsForCall []struct {
		arg1 context.Context
	}
	createTableLocksReturns struct {
		result1 error
	}
	createTableLocksReturnsOnCall map[int]struct {
		result1 error
	}
	CreateTableRevisionsStub        func(context.Context) error
	createTableRevisionsMutex       sync.RWMutex
	createTableRevisionsArgsForCall []struct {
		arg1 context.Context
	}
	createTableRevisionsReturns struct {
		result1 error
	}
	createTableRevisionsReturnsOnCall map[int]struct {
		result1 error
	}
	DatabaseStub        func() ent.DBTX
	databaseMutex       sync.RWMutex
	databaseArgsForCall []struct {
	}
	databaseReturns struct {
		result1 ent.DBTX
	}
	databaseReturnsOnCall map[int]struct {
		result1 ent.DBTX
	}
	DeleteJobStub        func(context.Context, *ent.DeleteJobParams) (*ent.Job, error)
	deleteJobMutex       sync.RWMutex
	deleteJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.DeleteJobParams
	}
	deleteJobReturns struct {
		result1 *ent.Job
		result2 error
	}
	deleteJobReturnsOnCall map[int]struct {
		result1 *ent.Job
		result2 error
	}
	DeleteLockStub        func(context.Context, *ent.DeleteLockParams) (*ent.Lock, error)
	deleteLockMutex       sync.RWMutex
	deleteLockArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.DeleteLockParams
	}
	deleteLockReturns struct {
		result1 *ent.Lock
		result2 error
	}
	deleteLockReturnsOnCall map[int]struct {
		result1 *ent.Lock
		result2 error
	}
	DeleteRevisionStub        func(context.Context, *ent.DeleteRevisionParams) (*ent.Revision, error)
	deleteRevisionMutex       sync.RWMutex
	deleteRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.DeleteRevisionParams
	}
	deleteRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	deleteRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	ExecDeleteJobStub        func(context.Context, *ent.ExecDeleteJobParams) error
	execDeleteJobMutex       sync.RWMutex
	execDeleteJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteJobParams
	}
	execDeleteJobReturns struct {
		result1 error
	}
	execDeleteJobReturnsOnCall map[int]struct {
		result1 error
	}
	ExecDeleteLockStub        func(context.Context, *ent.ExecDeleteLockParams) error
	execDeleteLockMutex       sync.RWMutex
	execDeleteLockArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteLockParams
	}
	execDeleteLockReturns struct {
		result1 error
	}
	execDeleteLockReturnsOnCall map[int]struct {
		result1 error
	}
	ExecDeleteRevisionStub        func(context.Context, *ent.ExecDeleteRevisionParams) error
	execDeleteRevisionMutex       sync.RWMutex
	execDeleteRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteRevisionParams
	}
	execDeleteRevisionReturns struct {
		result1 error
	}
	execDeleteRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertJobStub        func(context.Context, *ent.ExecInsertJobParams) error
	execInsertJobMutex       sync.RWMutex
	execInsertJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertJobParams
	}
	execInsertJobReturns struct {
		result1 error
	}
	execInsertJobReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertLockStub        func(context.Context, *ent.ExecInsertLockParams) error
	execInsertLockMutex       sync.RWMutex
	execInsertLockArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertLockParams
	}
	execInsertLockReturns struct {
		result1 error
	}
	execInsertLockReturnsOnCall map[int]struct {
		result1 error
	}
	ExecInsertRevisionStub        func(context.Context, *ent.ExecInsertRevisionParams) error
	execInsertRevisionMutex       sync.RWMutex
	execInsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}
	execInsertRevisionReturns struct {
		result1 error
	}
	execInsertRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	ExecUpdateRevisionStub        func(context.Context, *ent.ExecUpdateRevisionParams) error
	execUpdateRevisionMutex       sync.RWMutex
	execUpdateRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecUpdateRevisionParams
	}
	execUpdateRevisionReturns struct {
		result1 error
	}
	execUpdateRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	ExecUpsertRevisionStub        func(context.Context, *ent.ExecUpsertRevisionParams) error
	execUpsertRevisionMutex       sync.RWMutex
	execUpsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ExecUpsertRevisionParams
	}
	execUpsertRevisionReturns struct {
		result1 error
	}
	execUpsertRevisionReturnsOnCall map[int]struct {
		result1 error
	}
	GetJobStub        func(context.Context, *ent.GetJobParams) (*ent.Job, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetJobParams
	}
	getJobReturns struct {
		result1 *ent.Job
		result2 error
	}
	getJobReturnsOnCall map[int]struct {
		result1 *ent.Job
		result2 error
	}
	GetLockStub        func(context.Context, *ent.GetLockParams) (*ent.Lock, error)
	getLockMutex       sync.RWMutex
	getLockArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetLockParams
	}
	getLockReturns struct {
		result1 *ent.Lock
		result2 error
	}
	getLockReturnsOnCall map[int]struct {
		result1 *ent.Lock
		result2 error
	}
	GetRevisionStub        func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)
	getRevisionMutex       sync.RWMutex
	getRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}
	getRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	getRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	InsertJobStub        func(context.Context, *ent.InsertJobParams) (*ent.Job, error)
	insertJobMutex       sync.RWMutex
	insertJobArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertJobParams
	}
	insertJobReturns struct {
		result1 *ent.Job
		result2 error
	}
	insertJobReturnsOnCall map[int]struct {
		result1 *ent.Job
		result2 error
	}
	InsertLockStub        func(context.Context, *ent.InsertLockParams) (*ent.Lock, error)
	insertLockMutex       sync.RWMutex
	insertLockArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertLockParams
	}
	insertLockReturns struct {
		result1 *ent.Lock
		result2 error
	}
	insertLockReturnsOnCall map[int]struct {
		result1 *ent.Lock
		result2 error
	}
	InsertRevisionStub        func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)
	insertRevisionMutex       sync.RWMutex
	insertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}
	insertRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	insertRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	ListRevisionsStub        func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)
	listRevisionsMutex       sync.RWMutex
	listRevisionsArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}
	listRevisionsReturns struct {
		result1 []*ent.Revision
		result2 error
	}
	listRevisionsReturnsOnCall map[int]struct {
		result1 []*ent.Revision
		result2 error
	}
	PingStub        func(context.Context) error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 context.Context
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	RunInTxStub        func(context.Context, ent.QuerierAction) error
	runInTxMutex       sync.RWMutex
	runInTxArgsForCall []struct {
		arg1 context.Context
		arg2 ent.QuerierAction
	}
	runInTxReturns struct {
		result1 error
	}
	runInTxReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateRevisionStub        func(context.Context, *ent.UpdateRevisionParams) (*ent.Revision, error)
	updateRevisionMutex       sync.RWMutex
	updateRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.UpdateRevisionParams
	}
	updateRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	updateRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	UpsertRevisionStub        func(context.Context, *ent.UpsertRevisionParams) (*ent.Revision, error)
	upsertRevisionMutex       sync.RWMutex
	upsertRevisionArgsForCall []struct {
		arg1 context.Context
		arg2 *ent.UpsertRevisionParams
	}
	upsertRevisionReturns struct {
		result1 *ent.Revision
		result2 error
	}
	upsertRevisionReturnsOnCall map[int]struct {
		result1 *ent.Revision
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGateway) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeGateway) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeGateway) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeGateway) CreateSchemaSys(arg1 context.Context) error {
	fake.createSchemaSysMutex.Lock()
	ret, specificReturn := fake.createSchemaSysReturnsOnCall[len(fake.createSchemaSysArgsForCall)]
	fake.createSchemaSysArgsForCall = append(fake.createSchemaSysArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateSchemaSysStub
	fakeReturns := fake.createSchemaSysReturns
	fake.recordInvocation("CreateSchemaSys", []interface{}{arg1})
	fake.createSchemaSysMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) CreateSchemaSysCallCount() int {
	fake.createSchemaSysMutex.RLock()
	defer fake.createSchemaSysMutex.RUnlock()
	return len(fake.createSchemaSysArgsForCall)
}

func (fake *FakeGateway) CreateSchemaSysCalls(stub func(context.Context) error) {
	fake.createSchemaSysMutex.Lock()
	defer fake.createSchemaSysMutex.Unlock()
	fake.CreateSchemaSysStub = stub
}

func (fake *FakeGateway) CreateSchemaSysArgsForCall(i int) context.Context {
	fake.createSchemaSysMutex.RLock()
	defer fake.createSchemaSysMutex.RUnlock()
	argsForCall := fake.createSchemaSysArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) CreateSchemaSysReturns(result1 error) {
	fake.createSchemaSysMutex.Lock()
	defer fake.createSchemaSysMutex.Unlock()
	fake.CreateSchemaSysStub = nil
	fake.createSchemaSysReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateSchemaSysReturnsOnCall(i int, result1 error) {
	fake.createSchemaSysMutex.Lock()
	defer fake.createSchemaSysMutex.Unlock()
	fake.CreateSchemaSysStub = nil
	if fake.createSchemaSysReturnsOnCall == nil {
		fake.createSchemaSysReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSchemaSysReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableJobs(arg1 context.Context) error {
	fake.createTableJobsMutex.Lock()
	ret, specificReturn := fake.createTableJobsReturnsOnCall[len(fake.createTableJobsArgsForCall)]
	fake.createTableJobsArgsForCall = append(fake.createTableJobsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableJobsStub
	fakeReturns := fake.createTableJobsReturns
	fake.recordInvocation("CreateTableJobs", []interface{}{arg1})
	fake.createTableJobsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) CreateTableJobsCallCount() int {
	fake.createTableJobsMutex.RLock()
	defer fake.createTableJobsMutex.RUnlock()
	return len(fake.createTableJobsArgsForCall)
}

func (fake *FakeGateway) CreateTableJobsCalls(stub func(context.Context) error) {
	fake.createTableJobsMutex.Lock()
	defer fake.createTableJobsMutex.Unlock()
	fake.CreateTableJobsStub = stub
}

func (fake *FakeGateway) CreateTableJobsArgsForCall(i int) context.Context {
	fake.createTableJobsMutex.RLock()
	defer fake.createTableJobsMutex.RUnlock()
	argsForCall := fake.createTableJobsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) CreateTableJobsReturns(result1 error) {
	fake.createTableJobsMutex.Lock()
	defer fake.createTableJobsMutex.Unlock()
	fake.CreateTableJobsStub = nil
	fake.createTableJobsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableJobsReturnsOnCall(i int, result1 error) {
	fake.createTableJobsMutex.Lock()
	defer fake.createTableJobsMutex.Unlock()
	fake.CreateTableJobsStub = nil
	if fake.createTableJobsReturnsOnCall == nil {
		fake.createTableJobsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableJobsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableLocks(arg1 context.Context) error {
	fake.createTableLocksMutex.Lock()
	ret, specificReturn := fake.createTableLocksReturnsOnCall[len(fake.createTableLocksArgsForCall)]
	fake.createTableLocksArgsForCall = append(fake.createTableLocksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableLocksStub
	fakeReturns := fake.createTableLocksReturns
	fake.recordInvocation("CreateTableLocks", []interface{}{arg1})
	fake.createTableLocksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) CreateTableLocksCallCount() int {
	fake.createTableLocksMutex.RLock()
	defer fake.createTableLocksMutex.RUnlock()
	return len(fake.createTableLocksArgsForCall)
}

func (fake *FakeGateway) CreateTableLocksCalls(stub func(context.Context) error) {
	fake.createTableLocksMutex.Lock()
	defer fake.createTableLocksMutex.Unlock()
	fake.CreateTableLocksStub = stub
}

func (fake *FakeGateway) CreateTableLocksArgsForCall(i int) context.Context {
	fake.createTableLocksMutex.RLock()
	defer fake.createTableLocksMutex.RUnlock()
	argsForCall := fake.createTableLocksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) CreateTableLocksReturns(result1 error) {
	fake.createTableLocksMutex.Lock()
	defer fake.createTableLocksMutex.Unlock()
	fake.CreateTableLocksStub = nil
	fake.createTableLocksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableLocksReturnsOnCall(i int, result1 error) {
	fake.createTableLocksMutex.Lock()
	defer fake.createTableLocksMutex.Unlock()
	fake.CreateTableLocksStub = nil
	if fake.createTableLocksReturnsOnCall == nil {
		fake.createTableLocksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableLocksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableRevisions(arg1 context.Context) error {
	fake.createTableRevisionsMutex.Lock()
	ret, specificReturn := fake.createTableRevisionsReturnsOnCall[len(fake.createTableRevisionsArgsForCall)]
	fake.createTableRevisionsArgsForCall = append(fake.createTableRevisionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateTableRevisionsStub
	fakeReturns := fake.createTableRevisionsReturns
	fake.recordInvocation("CreateTableRevisions", []interface{}{arg1})
	fake.createTableRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) CreateTableRevisionsCallCount() int {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	return len(fake.createTableRevisionsArgsForCall)
}

func (fake *FakeGateway) CreateTableRevisionsCalls(stub func(context.Context) error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = stub
}

func (fake *FakeGateway) CreateTableRevisionsArgsForCall(i int) context.Context {
	fake.createTableRevisionsMutex.RLock()
	defer fake.createTableRevisionsMutex.RUnlock()
	argsForCall := fake.createTableRevisionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) CreateTableRevisionsReturns(result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	fake.createTableRevisionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) CreateTableRevisionsReturnsOnCall(i int, result1 error) {
	fake.createTableRevisionsMutex.Lock()
	defer fake.createTableRevisionsMutex.Unlock()
	fake.CreateTableRevisionsStub = nil
	if fake.createTableRevisionsReturnsOnCall == nil {
		fake.createTableRevisionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createTableRevisionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) Database() ent.DBTX {
	fake.databaseMutex.Lock()
	ret, specificReturn := fake.databaseReturnsOnCall[len(fake.databaseArgsForCall)]
	fake.databaseArgsForCall = append(fake.databaseArgsForCall, struct {
	}{})
	stub := fake.DatabaseStub
	fakeReturns := fake.databaseReturns
	fake.recordInvocation("Database", []interface{}{})
	fake.databaseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) DatabaseCallCount() int {
	fake.databaseMutex.RLock()
	defer fake.databaseMutex.RUnlock()
	return len(fake.databaseArgsForCall)
}

func (fake *FakeGateway) DatabaseCalls(stub func() ent.DBTX) {
	fake.databaseMutex.Lock()
	defer fake.databaseMutex.Unlock()
	fake.DatabaseStub = stub
}

func (fake *FakeGateway) DatabaseReturns(result1 ent.DBTX) {
	fake.databaseMutex.Lock()
	defer fake.databaseMutex.Unlock()
	fake.DatabaseStub = nil
	fake.databaseReturns = struct {
		result1 ent.DBTX
	}{result1}
}

func (fake *FakeGateway) DatabaseReturnsOnCall(i int, result1 ent.DBTX) {
	fake.databaseMutex.Lock()
	defer fake.databaseMutex.Unlock()
	fake.DatabaseStub = nil
	if fake.databaseReturnsOnCall == nil {
		fake.databaseReturnsOnCall = make(map[int]struct {
			result1 ent.DBTX
		})
	}
	fake.databaseReturnsOnCall[i] = struct {
		result1 ent.DBTX
	}{result1}
}

func (fake *FakeGateway) DeleteJob(arg1 context.Context, arg2 *ent.DeleteJobParams) (*ent.Job, error) {
	fake.deleteJobMutex.Lock()
	ret, specificReturn := fake.deleteJobReturnsOnCall[len(fake.deleteJobArgsForCall)]
	fake.deleteJobArgsForCall = append(fake.deleteJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.DeleteJobParams
	}{arg1, arg2})
	stub := fake.DeleteJobStub
	fakeReturns := fake.deleteJobReturns
	fake.recordInvocation("DeleteJob", []interface{}{arg1, arg2})
	fake.deleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) DeleteJobCallCount() int {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	return len(fake.deleteJobArgsForCall)
}

func (fake *FakeGateway) DeleteJobCalls(stub func(context.Context, *ent.DeleteJobParams) (*ent.Job, error)) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = stub
}

func (fake *FakeGateway) DeleteJobArgsForCall(i int) (context.Context, *ent.DeleteJobParams) {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	argsForCall := fake.deleteJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) DeleteJobReturns(result1 *ent.Job, result2 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	fake.deleteJobReturns = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) DeleteJobReturnsOnCall(i int, result1 *ent.Job, result2 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	if fake.deleteJobReturnsOnCall == nil {
		fake.deleteJobReturnsOnCall = make(map[int]struct {
			result1 *ent.Job
			result2 error
		})
	}
	fake.deleteJobReturnsOnCall[i] = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) DeleteLock(arg1 context.Context, arg2 *ent.DeleteLockParams) (*ent.Lock, error) {
	fake.deleteLockMutex.Lock()
	ret, specificReturn := fake.deleteLockReturnsOnCall[len(fake.deleteLockArgsForCall)]
	fake.deleteLockArgsForCall = append(fake.deleteLockArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.DeleteLockParams
	}{arg1, arg2})
	stub := fake.DeleteLockStub
	fakeReturns := fake.deleteLockReturns
	fake.recordInvocation("DeleteLock", []interface{}{arg1, arg2})
	fake.deleteLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) DeleteLockCallCount() int {
	fake.deleteLockMutex.RLock()
	defer fake.deleteLockMutex.RUnlock()
	return len(fake.deleteLockArgsForCall)
}

func (fake *FakeGateway) DeleteLockCalls(stub func(context.Context, *ent.DeleteLockParams) (*ent.Lock, error)) {
	fake.deleteLockMutex.Lock()
	defer fake.deleteLockMutex.Unlock()
	fake.DeleteLockStub = stub
}

func (fake *FakeGateway) DeleteLockArgsForCall(i int) (context.Context, *ent.DeleteLockParams) {
	fake.deleteLockMutex.RLock()
	defer fake.deleteLockMutex.RUnlock()
	argsForCall := fake.deleteLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) DeleteLockReturns(result1 *ent.Lock, result2 error) {
	fake.deleteLockMutex.Lock()
	defer fake.deleteLockMutex.Unlock()
	fake.DeleteLockStub = nil
	fake.deleteLockReturns = struct {
		result1 *ent.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) DeleteLockReturnsOnCall(i int, result1 *ent.Lock, result2 error) {
	fake.deleteLockMutex.Lock()
	defer fake.deleteLockMutex.Unlock()
	fake.DeleteLockStub = nil
	if fake.deleteLockReturnsOnCall == nil {
		fake.deleteLockReturnsOnCall = make(map[int]struct {
			result1 *ent.Lock
			result2 error
		})
	}
	fake.deleteLockReturnsOnCall[i] = struct {
		result1 *ent.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) DeleteRevision(arg1 context.Context, arg2 *ent.DeleteRevisionParams) (*ent.Revision, error) {
	fake.deleteRevisionMutex.Lock()
	ret, specificReturn := fake.deleteRevisionReturnsOnCall[len(fake.deleteRevisionArgsForCall)]
	fake.deleteRevisionArgsForCall = append(fake.deleteRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.DeleteRevisionParams
	}{arg1, arg2})
	stub := fake.DeleteRevisionStub
	fakeReturns := fake.deleteRevisionReturns
	fake.recordInvocation("DeleteRevision", []interface{}{arg1, arg2})
	fake.deleteRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) DeleteRevisionCallCount() int {
	fake.deleteRevisionMutex.RLock()
	defer fake.deleteRevisionMutex.RUnlock()
	return len(fake.deleteRevisionArgsForCall)
}

func (fake *FakeGateway) DeleteRevisionCalls(stub func(context.Context, *ent.DeleteRevisionParams) (*ent.Revision, error)) {
	fake.deleteRevisionMutex.Lock()
	defer fake.deleteRevisionMutex.Unlock()
	fake.DeleteRevisionStub = stub
}

func (fake *FakeGateway) DeleteRevisionArgsForCall(i int) (context.Context, *ent.DeleteRevisionParams) {
	fake.deleteRevisionMutex.RLock()
	defer fake.deleteRevisionMutex.RUnlock()
	argsForCall := fake.deleteRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) DeleteRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.deleteRevisionMutex.Lock()
	defer fake.deleteRevisionMutex.Unlock()
	fake.DeleteRevisionStub = nil
	fake.deleteRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) DeleteRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.deleteRevisionMutex.Lock()
	defer fake.deleteRevisionMutex.Unlock()
	fake.DeleteRevisionStub = nil
	if fake.deleteRevisionReturnsOnCall == nil {
		fake.deleteRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.deleteRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) ExecDeleteJob(arg1 context.Context, arg2 *ent.ExecDeleteJobParams) error {
	fake.execDeleteJobMutex.Lock()
	ret, specificReturn := fake.execDeleteJobReturnsOnCall[len(fake.execDeleteJobArgsForCall)]
	fake.execDeleteJobArgsForCall = append(fake.execDeleteJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteJobParams
	}{arg1, arg2})
	stub := fake.ExecDeleteJobStub
	fakeReturns := fake.execDeleteJobReturns
	fake.recordInvocation("ExecDeleteJob", []interface{}{arg1, arg2})
	fake.execDeleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecDeleteJobCallCount() int {
	fake.execDeleteJobMutex.RLock()
	defer fake.execDeleteJobMutex.RUnlock()
	return len(fake.execDeleteJobArgsForCall)
}

func (fake *FakeGateway) ExecDeleteJobCalls(stub func(context.Context, *ent.ExecDeleteJobParams) error) {
	fake.execDeleteJobMutex.Lock()
	defer fake.execDeleteJobMutex.Unlock()
	fake.ExecDeleteJobStub = stub
}

func (fake *FakeGateway) ExecDeleteJobArgsForCall(i int) (context.Context, *ent.ExecDeleteJobParams) {
	fake.execDeleteJobMutex.RLock()
	defer fake.execDeleteJobMutex.RUnlock()
	argsForCall := fake.execDeleteJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecDeleteJobReturns(result1 error) {
	fake.execDeleteJobMutex.Lock()
	defer fake.execDeleteJobMutex.Unlock()
	fake.ExecDeleteJobStub = nil
	fake.execDeleteJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecDeleteJobReturnsOnCall(i int, result1 error) {
	fake.execDeleteJobMutex.Lock()
	defer fake.execDeleteJobMutex.Unlock()
	fake.ExecDeleteJobStub = nil
	if fake.execDeleteJobReturnsOnCall == nil {
		fake.execDeleteJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execDeleteJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecDeleteLock(arg1 context.Context, arg2 *ent.ExecDeleteLockParams) error {
	fake.execDeleteLockMutex.Lock()
	ret, specificReturn := fake.execDeleteLockReturnsOnCall[len(fake.execDeleteLockArgsForCall)]
	fake.execDeleteLockArgsForCall = append(fake.execDeleteLockArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteLockParams
	}{arg1, arg2})
	stub := fake.ExecDeleteLockStub
	fakeReturns := fake.execDeleteLockReturns
	fake.recordInvocation("ExecDeleteLock", []interface{}{arg1, arg2})
	fake.execDeleteLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecDeleteLockCallCount() int {
	fake.execDeleteLockMutex.RLock()
	defer fake.execDeleteLockMutex.RUnlock()
	return len(fake.execDeleteLockArgsForCall)
}

func (fake *FakeGateway) ExecDeleteLockCalls(stub func(context.Context, *ent.ExecDeleteLockParams) error) {
	fake.execDeleteLockMutex.Lock()
	defer fake.execDeleteLockMutex.Unlock()
	fake.ExecDeleteLockStub = stub
}

func (fake *FakeGateway) ExecDeleteLockArgsForCall(i int) (context.Context, *ent.ExecDeleteLockParams) {
	fake.execDeleteLockMutex.RLock()
	defer fake.execDeleteLockMutex.RUnlock()
	argsForCall := fake.execDeleteLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecDeleteLockReturns(result1 error) {
	fake.execDeleteLockMutex.Lock()
	defer fake.execDeleteLockMutex.Unlock()
	fake.ExecDeleteLockStub = nil
	fake.execDeleteLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecDeleteLockReturnsOnCall(i int, result1 error) {
	fake.execDeleteLockMutex.Lock()
	defer fake.execDeleteLockMutex.Unlock()
	fake.ExecDeleteLockStub = nil
	if fake.execDeleteLockReturnsOnCall == nil {
		fake.execDeleteLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execDeleteLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecDeleteRevision(arg1 context.Context, arg2 *ent.ExecDeleteRevisionParams) error {
	fake.execDeleteRevisionMutex.Lock()
	ret, specificReturn := fake.execDeleteRevisionReturnsOnCall[len(fake.execDeleteRevisionArgsForCall)]
	fake.execDeleteRevisionArgsForCall = append(fake.execDeleteRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecDeleteRevisionParams
	}{arg1, arg2})
	stub := fake.ExecDeleteRevisionStub
	fakeReturns := fake.execDeleteRevisionReturns
	fake.recordInvocation("ExecDeleteRevision", []interface{}{arg1, arg2})
	fake.execDeleteRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecDeleteRevisionCallCount() int {
	fake.execDeleteRevisionMutex.RLock()
	defer fake.execDeleteRevisionMutex.RUnlock()
	return len(fake.execDeleteRevisionArgsForCall)
}

func (fake *FakeGateway) ExecDeleteRevisionCalls(stub func(context.Context, *ent.ExecDeleteRevisionParams) error) {
	fake.execDeleteRevisionMutex.Lock()
	defer fake.execDeleteRevisionMutex.Unlock()
	fake.ExecDeleteRevisionStub = stub
}

func (fake *FakeGateway) ExecDeleteRevisionArgsForCall(i int) (context.Context, *ent.ExecDeleteRevisionParams) {
	fake.execDeleteRevisionMutex.RLock()
	defer fake.execDeleteRevisionMutex.RUnlock()
	argsForCall := fake.execDeleteRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecDeleteRevisionReturns(result1 error) {
	fake.execDeleteRevisionMutex.Lock()
	defer fake.execDeleteRevisionMutex.Unlock()
	fake.ExecDeleteRevisionStub = nil
	fake.execDeleteRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecDeleteRevisionReturnsOnCall(i int, result1 error) {
	fake.execDeleteRevisionMutex.Lock()
	defer fake.execDeleteRevisionMutex.Unlock()
	fake.ExecDeleteRevisionStub = nil
	if fake.execDeleteRevisionReturnsOnCall == nil {
		fake.execDeleteRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execDeleteRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertJob(arg1 context.Context, arg2 *ent.ExecInsertJobParams) error {
	fake.execInsertJobMutex.Lock()
	ret, specificReturn := fake.execInsertJobReturnsOnCall[len(fake.execInsertJobArgsForCall)]
	fake.execInsertJobArgsForCall = append(fake.execInsertJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertJobParams
	}{arg1, arg2})
	stub := fake.ExecInsertJobStub
	fakeReturns := fake.execInsertJobReturns
	fake.recordInvocation("ExecInsertJob", []interface{}{arg1, arg2})
	fake.execInsertJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecInsertJobCallCount() int {
	fake.execInsertJobMutex.RLock()
	defer fake.execInsertJobMutex.RUnlock()
	return len(fake.execInsertJobArgsForCall)
}

func (fake *FakeGateway) ExecInsertJobCalls(stub func(context.Context, *ent.ExecInsertJobParams) error) {
	fake.execInsertJobMutex.Lock()
	defer fake.execInsertJobMutex.Unlock()
	fake.ExecInsertJobStub = stub
}

func (fake *FakeGateway) ExecInsertJobArgsForCall(i int) (context.Context, *ent.ExecInsertJobParams) {
	fake.execInsertJobMutex.RLock()
	defer fake.execInsertJobMutex.RUnlock()
	argsForCall := fake.execInsertJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecInsertJobReturns(result1 error) {
	fake.execInsertJobMutex.Lock()
	defer fake.execInsertJobMutex.Unlock()
	fake.ExecInsertJobStub = nil
	fake.execInsertJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertJobReturnsOnCall(i int, result1 error) {
	fake.execInsertJobMutex.Lock()
	defer fake.execInsertJobMutex.Unlock()
	fake.ExecInsertJobStub = nil
	if fake.execInsertJobReturnsOnCall == nil {
		fake.execInsertJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertLock(arg1 context.Context, arg2 *ent.ExecInsertLockParams) error {
	fake.execInsertLockMutex.Lock()
	ret, specificReturn := fake.execInsertLockReturnsOnCall[len(fake.execInsertLockArgsForCall)]
	fake.execInsertLockArgsForCall = append(fake.execInsertLockArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertLockParams
	}{arg1, arg2})
	stub := fake.ExecInsertLockStub
	fakeReturns := fake.execInsertLockReturns
	fake.recordInvocation("ExecInsertLock", []interface{}{arg1, arg2})
	fake.execInsertLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecInsertLockCallCount() int {
	fake.execInsertLockMutex.RLock()
	defer fake.execInsertLockMutex.RUnlock()
	return len(fake.execInsertLockArgsForCall)
}

func (fake *FakeGateway) ExecInsertLockCalls(stub func(context.Context, *ent.ExecInsertLockParams) error) {
	fake.execInsertLockMutex.Lock()
	defer fake.execInsertLockMutex.Unlock()
	fake.ExecInsertLockStub = stub
}

func (fake *FakeGateway) ExecInsertLockArgsForCall(i int) (context.Context, *ent.ExecInsertLockParams) {
	fake.execInsertLockMutex.RLock()
	defer fake.execInsertLockMutex.RUnlock()
	argsForCall := fake.execInsertLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecInsertLockReturns(result1 error) {
	fake.execInsertLockMutex.Lock()
	defer fake.execInsertLockMutex.Unlock()
	fake.ExecInsertLockStub = nil
	fake.execInsertLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertLockReturnsOnCall(i int, result1 error) {
	fake.execInsertLockMutex.Lock()
	defer fake.execInsertLockMutex.Unlock()
	fake.ExecInsertLockStub = nil
	if fake.execInsertLockReturnsOnCall == nil {
		fake.execInsertLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertRevision(arg1 context.Context, arg2 *ent.ExecInsertRevisionParams) error {
	fake.execInsertRevisionMutex.Lock()
	ret, specificReturn := fake.execInsertRevisionReturnsOnCall[len(fake.execInsertRevisionArgsForCall)]
	fake.execInsertRevisionArgsForCall = append(fake.execInsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecInsertRevisionParams
	}{arg1, arg2})
	stub := fake.ExecInsertRevisionStub
	fakeReturns := fake.execInsertRevisionReturns
	fake.recordInvocation("ExecInsertRevision", []interface{}{arg1, arg2})
	fake.execInsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecInsertRevisionCallCount() int {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	return len(fake.execInsertRevisionArgsForCall)
}

func (fake *FakeGateway) ExecInsertRevisionCalls(stub func(context.Context, *ent.ExecInsertRevisionParams) error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = stub
}

func (fake *FakeGateway) ExecInsertRevisionArgsForCall(i int) (context.Context, *ent.ExecInsertRevisionParams) {
	fake.execInsertRevisionMutex.RLock()
	defer fake.execInsertRevisionMutex.RUnlock()
	argsForCall := fake.execInsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecInsertRevisionReturns(result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	fake.execInsertRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecInsertRevisionReturnsOnCall(i int, result1 error) {
	fake.execInsertRevisionMutex.Lock()
	defer fake.execInsertRevisionMutex.Unlock()
	fake.ExecInsertRevisionStub = nil
	if fake.execInsertRevisionReturnsOnCall == nil {
		fake.execInsertRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execInsertRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecUpdateRevision(arg1 context.Context, arg2 *ent.ExecUpdateRevisionParams) error {
	fake.execUpdateRevisionMutex.Lock()
	ret, specificReturn := fake.execUpdateRevisionReturnsOnCall[len(fake.execUpdateRevisionArgsForCall)]
	fake.execUpdateRevisionArgsForCall = append(fake.execUpdateRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecUpdateRevisionParams
	}{arg1, arg2})
	stub := fake.ExecUpdateRevisionStub
	fakeReturns := fake.execUpdateRevisionReturns
	fake.recordInvocation("ExecUpdateRevision", []interface{}{arg1, arg2})
	fake.execUpdateRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecUpdateRevisionCallCount() int {
	fake.execUpdateRevisionMutex.RLock()
	defer fake.execUpdateRevisionMutex.RUnlock()
	return len(fake.execUpdateRevisionArgsForCall)
}

func (fake *FakeGateway) ExecUpdateRevisionCalls(stub func(context.Context, *ent.ExecUpdateRevisionParams) error) {
	fake.execUpdateRevisionMutex.Lock()
	defer fake.execUpdateRevisionMutex.Unlock()
	fake.ExecUpdateRevisionStub = stub
}

func (fake *FakeGateway) ExecUpdateRevisionArgsForCall(i int) (context.Context, *ent.ExecUpdateRevisionParams) {
	fake.execUpdateRevisionMutex.RLock()
	defer fake.execUpdateRevisionMutex.RUnlock()
	argsForCall := fake.execUpdateRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecUpdateRevisionReturns(result1 error) {
	fake.execUpdateRevisionMutex.Lock()
	defer fake.execUpdateRevisionMutex.Unlock()
	fake.ExecUpdateRevisionStub = nil
	fake.execUpdateRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecUpdateRevisionReturnsOnCall(i int, result1 error) {
	fake.execUpdateRevisionMutex.Lock()
	defer fake.execUpdateRevisionMutex.Unlock()
	fake.ExecUpdateRevisionStub = nil
	if fake.execUpdateRevisionReturnsOnCall == nil {
		fake.execUpdateRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execUpdateRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecUpsertRevision(arg1 context.Context, arg2 *ent.ExecUpsertRevisionParams) error {
	fake.execUpsertRevisionMutex.Lock()
	ret, specificReturn := fake.execUpsertRevisionReturnsOnCall[len(fake.execUpsertRevisionArgsForCall)]
	fake.execUpsertRevisionArgsForCall = append(fake.execUpsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ExecUpsertRevisionParams
	}{arg1, arg2})
	stub := fake.ExecUpsertRevisionStub
	fakeReturns := fake.execUpsertRevisionReturns
	fake.recordInvocation("ExecUpsertRevision", []interface{}{arg1, arg2})
	fake.execUpsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) ExecUpsertRevisionCallCount() int {
	fake.execUpsertRevisionMutex.RLock()
	defer fake.execUpsertRevisionMutex.RUnlock()
	return len(fake.execUpsertRevisionArgsForCall)
}

func (fake *FakeGateway) ExecUpsertRevisionCalls(stub func(context.Context, *ent.ExecUpsertRevisionParams) error) {
	fake.execUpsertRevisionMutex.Lock()
	defer fake.execUpsertRevisionMutex.Unlock()
	fake.ExecUpsertRevisionStub = stub
}

func (fake *FakeGateway) ExecUpsertRevisionArgsForCall(i int) (context.Context, *ent.ExecUpsertRevisionParams) {
	fake.execUpsertRevisionMutex.RLock()
	defer fake.execUpsertRevisionMutex.RUnlock()
	argsForCall := fake.execUpsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ExecUpsertRevisionReturns(result1 error) {
	fake.execUpsertRevisionMutex.Lock()
	defer fake.execUpsertRevisionMutex.Unlock()
	fake.ExecUpsertRevisionStub = nil
	fake.execUpsertRevisionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) ExecUpsertRevisionReturnsOnCall(i int, result1 error) {
	fake.execUpsertRevisionMutex.Lock()
	defer fake.execUpsertRevisionMutex.Unlock()
	fake.ExecUpsertRevisionStub = nil
	if fake.execUpsertRevisionReturnsOnCall == nil {
		fake.execUpsertRevisionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execUpsertRevisionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) GetJob(arg1 context.Context, arg2 *ent.GetJobParams) (*ent.Job, error) {
	fake.getJobMutex.Lock()
	ret, specificReturn := fake.getJobReturnsOnCall[len(fake.getJobArgsForCall)]
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetJobParams
	}{arg1, arg2})
	stub := fake.GetJobStub
	fakeReturns := fake.getJobReturns
	fake.recordInvocation("GetJob", []interface{}{arg1, arg2})
	fake.getJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakeGateway) GetJobCalls(stub func(context.Context, *ent.GetJobParams) (*ent.Job, error)) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = stub
}

func (fake *FakeGateway) GetJobArgsForCall(i int) (context.Context, *ent.GetJobParams) {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	argsForCall := fake.getJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) GetJobReturns(result1 *ent.Job, result2 error) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) GetJobReturnsOnCall(i int, result1 *ent.Job, result2 error) {
	fake.getJobMutex.Lock()
	defer fake.getJobMutex.Unlock()
	fake.GetJobStub = nil
	if fake.getJobReturnsOnCall == nil {
		fake.getJobReturnsOnCall = make(map[int]struct {
			result1 *ent.Job
			result2 error
		})
	}
	fake.getJobReturnsOnCall[i] = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) GetLock(arg1 context.Context, arg2 *ent.GetLockParams) (*ent.Lock, error) {
	fake.getLockMutex.Lock()
	ret, specificReturn := fake.getLockReturnsOnCall[len(fake.getLockArgsForCall)]
	fake.getLockArgsForCall = append(fake.getLockArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetLockParams
	}{arg1, arg2})
	stub := fake.GetLockStub
	fakeReturns := fake.getLockReturns
	fake.recordInvocation("GetLock", []interface{}{arg1, arg2})
	fake.getLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) GetLockCallCount() int {
	fake.getLockMutex.RLock()
	defer fake.getLockMutex.RUnlock()
	return len(fake.getLockArgsForCall)
}

func (fake *FakeGateway) GetLockCalls(stub func(context.Context, *ent.GetLockParams) (*ent.Lock, error)) {
	fake.getLockMutex.Lock()
	defer fake.getLockMutex.Unlock()
	fake.GetLockStub = stub
}

func (fake *FakeGateway) GetLockArgsForCall(i int) (context.Context, *ent.GetLockParams) {
	fake.getLockMutex.RLock()
	defer fake.getLockMutex.RUnlock()
	argsForCall := fake.getLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) GetLockReturns(result1 *ent.Lock, result2 error) {
	fake.getLockMutex.Lock()
	defer fake.getLockMutex.Unlock()
	fake.GetLockStub = nil
	fake.getLockReturns = struct {
		result1 *ent.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) GetLockReturnsOnCall(i int, result1 *ent.Lock, result2 error) {
	fake.getLockMutex.Lock()
	defer fake.getLockMutex.Unlock()
	fake.GetLockStub = nil
	if fake.getLockReturnsOnCall == nil {
		fake.getLockReturnsOnCall = make(map[int]struct {
			result1 *ent.Lock
			result2 error
		})
	}
	fake.getLockReturnsOnCall[i] = struct {
		result1 *ent.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) GetRevision(arg1 context.Context, arg2 *ent.GetRevisionParams) (*ent.Revision, error) {
	fake.getRevisionMutex.Lock()
	ret, specificReturn := fake.getRevisionReturnsOnCall[len(fake.getRevisionArgsForCall)]
	fake.getRevisionArgsForCall = append(fake.getRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.GetRevisionParams
	}{arg1, arg2})
	stub := fake.GetRevisionStub
	fakeReturns := fake.getRevisionReturns
	fake.recordInvocation("GetRevision", []interface{}{arg1, arg2})
	fake.getRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) GetRevisionCallCount() int {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	return len(fake.getRevisionArgsForCall)
}

func (fake *FakeGateway) GetRevisionCalls(stub func(context.Context, *ent.GetRevisionParams) (*ent.Revision, error)) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = stub
}

func (fake *FakeGateway) GetRevisionArgsForCall(i int) (context.Context, *ent.GetRevisionParams) {
	fake.getRevisionMutex.RLock()
	defer fake.getRevisionMutex.RUnlock()
	argsForCall := fake.getRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) GetRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	fake.getRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) GetRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.getRevisionMutex.Lock()
	defer fake.getRevisionMutex.Unlock()
	fake.GetRevisionStub = nil
	if fake.getRevisionReturnsOnCall == nil {
		fake.getRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.getRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertJob(arg1 context.Context, arg2 *ent.InsertJobParams) (*ent.Job, error) {
	fake.insertJobMutex.Lock()
	ret, specificReturn := fake.insertJobReturnsOnCall[len(fake.insertJobArgsForCall)]
	fake.insertJobArgsForCall = append(fake.insertJobArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertJobParams
	}{arg1, arg2})
	stub := fake.InsertJobStub
	fakeReturns := fake.insertJobReturns
	fake.recordInvocation("InsertJob", []interface{}{arg1, arg2})
	fake.insertJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) InsertJobCallCount() int {
	fake.insertJobMutex.RLock()
	defer fake.insertJobMutex.RUnlock()
	return len(fake.insertJobArgsForCall)
}

func (fake *FakeGateway) InsertJobCalls(stub func(context.Context, *ent.InsertJobParams) (*ent.Job, error)) {
	fake.insertJobMutex.Lock()
	defer fake.insertJobMutex.Unlock()
	fake.InsertJobStub = stub
}

func (fake *FakeGateway) InsertJobArgsForCall(i int) (context.Context, *ent.InsertJobParams) {
	fake.insertJobMutex.RLock()
	defer fake.insertJobMutex.RUnlock()
	argsForCall := fake.insertJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) InsertJobReturns(result1 *ent.Job, result2 error) {
	fake.insertJobMutex.Lock()
	defer fake.insertJobMutex.Unlock()
	fake.InsertJobStub = nil
	fake.insertJobReturns = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertJobReturnsOnCall(i int, result1 *ent.Job, result2 error) {
	fake.insertJobMutex.Lock()
	defer fake.insertJobMutex.Unlock()
	fake.InsertJobStub = nil
	if fake.insertJobReturnsOnCall == nil {
		fake.insertJobReturnsOnCall = make(map[int]struct {
			result1 *ent.Job
			result2 error
		})
	}
	fake.insertJobReturnsOnCall[i] = struct {
		result1 *ent.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertLock(arg1 context.Context, arg2 *ent.InsertLockParams) (*ent.Lock, error) {
	fake.insertLockMutex.Lock()
	ret, specificReturn := fake.insertLockReturnsOnCall[len(fake.insertLockArgsForCall)]
	fake.insertLockArgsForCall = append(fake.insertLockArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertLockParams
	}{arg1, arg2})
	stub := fake.InsertLockStub
	fakeReturns := fake.insertLockReturns
	fake.recordInvocation("InsertLock", []interface{}{arg1, arg2})
	fake.insertLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) InsertLockCallCount() int {
	fake.insertLockMutex.RLock()
	defer fake.insertLockMutex.RUnlock()
	return len(fake.insertLockArgsForCall)
}

func (fake *FakeGateway) InsertLockCalls(stub func(context.Context, *ent.InsertLockParams) (*ent.Lock, error)) {
	fake.insertLockMutex.Lock()
	defer fake.insertLockMutex.Unlock()
	fake.InsertLockStub = stub
}

func (fake *FakeGateway) InsertLockArgsForCall(i int) (context.Context, *ent.InsertLockParams) {
	fake.insertLockMutex.RLock()
	defer fake.insertLockMutex.RUnlock()
	argsForCall := fake.insertLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) InsertLockReturns(result1 *ent.Lock, result2 error) {
	fake.insertLockMutex.Lock()
	defer fake.insertLockMutex.Unlock()
	fake.InsertLockStub = nil
	fake.insertLockReturns = struct {
		result1 *ent.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertLockReturnsOnCall(i int, result1 *ent.Lock, result2 error) {
	fake.insertLockMutex.Lock()
	defer fake.insertLockMutex.Unlock()
	fake.InsertLockStub = nil
	if fake.insertLockReturnsOnCall == nil {
		fake.insertLockReturnsOnCall = make(map[int]struct {
			result1 *ent.Lock
			result2 error
		})
	}
	fake.insertLockReturnsOnCall[i] = struct {
		result1 *ent.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertRevision(arg1 context.Context, arg2 *ent.InsertRevisionParams) (*ent.Revision, error) {
	fake.insertRevisionMutex.Lock()
	ret, specificReturn := fake.insertRevisionReturnsOnCall[len(fake.insertRevisionArgsForCall)]
	fake.insertRevisionArgsForCall = append(fake.insertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.InsertRevisionParams
	}{arg1, arg2})
	stub := fake.InsertRevisionStub
	fakeReturns := fake.insertRevisionReturns
	fake.recordInvocation("InsertRevision", []interface{}{arg1, arg2})
	fake.insertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) InsertRevisionCallCount() int {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	return len(fake.insertRevisionArgsForCall)
}

func (fake *FakeGateway) InsertRevisionCalls(stub func(context.Context, *ent.InsertRevisionParams) (*ent.Revision, error)) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = stub
}

func (fake *FakeGateway) InsertRevisionArgsForCall(i int) (context.Context, *ent.InsertRevisionParams) {
	fake.insertRevisionMutex.RLock()
	defer fake.insertRevisionMutex.RUnlock()
	argsForCall := fake.insertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) InsertRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	fake.insertRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) InsertRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.insertRevisionMutex.Lock()
	defer fake.insertRevisionMutex.Unlock()
	fake.InsertRevisionStub = nil
	if fake.insertRevisionReturnsOnCall == nil {
		fake.insertRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.insertRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) ListRevisions(arg1 context.Context, arg2 *ent.ListRevisionsParams) ([]*ent.Revision, error) {
	fake.listRevisionsMutex.Lock()
	ret, specificReturn := fake.listRevisionsReturnsOnCall[len(fake.listRevisionsArgsForCall)]
	fake.listRevisionsArgsForCall = append(fake.listRevisionsArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.ListRevisionsParams
	}{arg1, arg2})
	stub := fake.ListRevisionsStub
	fakeReturns := fake.listRevisionsReturns
	fake.recordInvocation("ListRevisions", []interface{}{arg1, arg2})
	fake.listRevisionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) ListRevisionsCallCount() int {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	return len(fake.listRevisionsArgsForCall)
}

func (fake *FakeGateway) ListRevisionsCalls(stub func(context.Context, *ent.ListRevisionsParams) ([]*ent.Revision, error)) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = stub
}

func (fake *FakeGateway) ListRevisionsArgsForCall(i int) (context.Context, *ent.ListRevisionsParams) {
	fake.listRevisionsMutex.RLock()
	defer fake.listRevisionsMutex.RUnlock()
	argsForCall := fake.listRevisionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) ListRevisionsReturns(result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	fake.listRevisionsReturns = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) ListRevisionsReturnsOnCall(i int, result1 []*ent.Revision, result2 error) {
	fake.listRevisionsMutex.Lock()
	defer fake.listRevisionsMutex.Unlock()
	fake.ListRevisionsStub = nil
	if fake.listRevisionsReturnsOnCall == nil {
		fake.listRevisionsReturnsOnCall = make(map[int]struct {
			result1 []*ent.Revision
			result2 error
		})
	}
	fake.listRevisionsReturnsOnCall[i] = struct {
		result1 []*ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) Ping(arg1 context.Context) error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{arg1})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeGateway) PingCalls(stub func(context.Context) error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeGateway) PingArgsForCall(i int) context.Context {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGateway) PingReturns(result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) PingReturnsOnCall(i int, result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) RunInTx(arg1 context.Context, arg2 ent.QuerierAction) error {
	fake.runInTxMutex.Lock()
	ret, specificReturn := fake.runInTxReturnsOnCall[len(fake.runInTxArgsForCall)]
	fake.runInTxArgsForCall = append(fake.runInTxArgsForCall, struct {
		arg1 context.Context
		arg2 ent.QuerierAction
	}{arg1, arg2})
	stub := fake.RunInTxStub
	fakeReturns := fake.runInTxReturns
	fake.recordInvocation("RunInTx", []interface{}{arg1, arg2})
	fake.runInTxMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGateway) RunInTxCallCount() int {
	fake.runInTxMutex.RLock()
	defer fake.runInTxMutex.RUnlock()
	return len(fake.runInTxArgsForCall)
}

func (fake *FakeGateway) RunInTxCalls(stub func(context.Context, ent.QuerierAction) error) {
	fake.runInTxMutex.Lock()
	defer fake.runInTxMutex.Unlock()
	fake.RunInTxStub = stub
}

func (fake *FakeGateway) RunInTxArgsForCall(i int) (context.Context, ent.QuerierAction) {
	fake.runInTxMutex.RLock()
	defer fake.runInTxMutex.RUnlock()
	argsForCall := fake.runInTxArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) RunInTxReturns(result1 error) {
	fake.runInTxMutex.Lock()
	defer fake.runInTxMutex.Unlock()
	fake.RunInTxStub = nil
	fake.runInTxReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) RunInTxReturnsOnCall(i int, result1 error) {
	fake.runInTxMutex.Lock()
	defer fake.runInTxMutex.Unlock()
	fake.RunInTxStub = nil
	if fake.runInTxReturnsOnCall == nil {
		fake.runInTxReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runInTxReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGateway) UpdateRevision(arg1 context.Context, arg2 *ent.UpdateRevisionParams) (*ent.Revision, error) {
	fake.updateRevisionMutex.Lock()
	ret, specificReturn := fake.updateRevisionReturnsOnCall[len(fake.updateRevisionArgsForCall)]
	fake.updateRevisionArgsForCall = append(fake.updateRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.UpdateRevisionParams
	}{arg1, arg2})
	stub := fake.UpdateRevisionStub
	fakeReturns := fake.updateRevisionReturns
	fake.recordInvocation("UpdateRevision", []interface{}{arg1, arg2})
	fake.updateRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) UpdateRevisionCallCount() int {
	fake.updateRevisionMutex.RLock()
	defer fake.updateRevisionMutex.RUnlock()
	return len(fake.updateRevisionArgsForCall)
}

func (fake *FakeGateway) UpdateRevisionCalls(stub func(context.Context, *ent.UpdateRevisionParams) (*ent.Revision, error)) {
	fake.updateRevisionMutex.Lock()
	defer fake.updateRevisionMutex.Unlock()
	fake.UpdateRevisionStub = stub
}

func (fake *FakeGateway) UpdateRevisionArgsForCall(i int) (context.Context, *ent.UpdateRevisionParams) {
	fake.updateRevisionMutex.RLock()
	defer fake.updateRevisionMutex.RUnlock()
	argsForCall := fake.updateRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) UpdateRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.updateRevisionMutex.Lock()
	defer fake.updateRevisionMutex.Unlock()
	fake.UpdateRevisionStub = nil
	fake.updateRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) UpdateRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.updateRevisionMutex.Lock()
	defer fake.updateRevisionMutex.Unlock()
	fake.UpdateRevisionStub = nil
	if fake.updateRevisionReturnsOnCall == nil {
		fake.updateRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.updateRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) UpsertRevision(arg1 context.Context, arg2 *ent.UpsertRevisionParams) (*ent.Revision, error) {
	fake.upsertRevisionMutex.Lock()
	ret, specificReturn := fake.upsertRevisionReturnsOnCall[len(fake.upsertRevisionArgsForCall)]
	fake.upsertRevisionArgsForCall = append(fake.upsertRevisionArgsForCall, struct {
		arg1 context.Context
		arg2 *ent.UpsertRevisionParams
	}{arg1, arg2})
	stub := fake.UpsertRevisionStub
	fakeReturns := fake.upsertRevisionReturns
	fake.recordInvocation("UpsertRevision", []interface{}{arg1, arg2})
	fake.upsertRevisionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGateway) UpsertRevisionCallCount() int {
	fake.upsertRevisionMutex.RLock()
	defer fake.upsertRevisionMutex.RUnlock()
	return len(fake.upsertRevisionArgsForCall)
}

func (fake *FakeGateway) UpsertRevisionCalls(stub func(context.Context, *ent.UpsertRevisionParams) (*ent.Revision, error)) {
	fake.upsertRevisionMutex.Lock()
	defer fake.upsertRevisionMutex.Unlock()
	fake.UpsertRevisionStub = stub
}

func (fake *FakeGateway) UpsertRevisionArgsForCall(i int) (context.Context, *ent.UpsertRevisionParams) {
	fake.upsertRevisionMutex.RLock()
	defer fake.upsertRevisionMutex.RUnlock()
	argsForCall := fake.upsertRevisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGateway) UpsertRevisionReturns(result1 *ent.Revision, result2 error) {
	fake.upsertRevisionMutex.Lock()
	defer fake.upsertRevisionMutex.Unlock()
	fake.UpsertRevisionStub = nil
	fake.upsertRevisionReturns = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) UpsertRevisionReturnsOnCall(i int, result1 *ent.Revision, result2 error) {
	fake.upsertRevisionMutex.Lock()
	defer fake.upsertRevisionMutex.Unlock()
	fake.UpsertRevisionStub = nil
	if fake.upsertRevisionReturnsOnCall == nil {
		fake.upsertRevisionReturnsOnCall = make(map[int]struct {
			result1 *ent.Revision
			result2 error
		})
	}
	fake.upsertRevisionReturnsOnCall[i] = struct {
		result1 *ent.Revision
		result2 error
	}{result1, result2}
}

func (fake *FakeGateway) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGateway) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ent.Gateway = new(FakeGateway)
